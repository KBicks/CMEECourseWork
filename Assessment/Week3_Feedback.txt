Starting weekly assessment for Katherine, Week3

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 4.24 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week6, Week1, Week7, Assessment, Week5, Week2, Week9, Week4, .git, Miniproject, Week3, Project

Found the following files in parent directory: .gitignore, readme.md

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
*~ 
*.tmp
*.pcy
__pycache__
*.Rhistory
*.gz
*.aux
*.log
*.blg
*.bbl
**********************************************************************

Found README in parent directory, named: readme.md

Printing contents of readme.md:
**********************************************************************
### CMEE Coursework Repository 2018/19 README
  
*Author:* Katie Bickerton
  
*Contents:*  
**Week{1-9}** - exercises from the taught content of the course.  
**Miniproject** - script and data files for the CMEE mini-project, (this is also the week 8 directory).  
**Project** - script and data files for the 9 month research project.  
**Assessment** - feedback on the taught content from the assessor.  
**.gitignore** - file types within the home directory but not kept under version control.  **********************************************************************

======================================================================
Looking for the weekly directories...

Found 8 weekly directories: Week1, Week2, Week3, Week4, Week5, Week6, Week7, Week9

The Week3 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK3...

Found the following directories: Code, Data, Results

Found the following files: readme.md

Checking for readme file in weekly directory...

Found README in parent directory, named: readme.md

Printing contents of readme.md:
**********************************************************************
### CMEE Coursework Week 3 README

*Introduction:* This directory contains coursework files from week 3 of the CMEE course. This week included an introduction to R and data management, exploration and visualisation using R. Some scripts used to run R scripts are written in bash and written analysis has been carried out in LaTeX.
  
*Contents:* There are three directories:
1. **Code** - script files in R, bash and LaTeX.
2. **Data** - data used to test code scripts.
3. **Results** - location for output files produced by script files.
   
*Code File Descriptions:*  
Biological Computing in R:  
**sample.R** - Exemplifies generating a vector of 100 random values using a function and the command 'sample()', then how to run function using vectorization or a for loop.  
**basic_io.R** - Demonstrating input and output of csv files, including appending.  
**boilerplate.R** - A boilerplate script exemplifying printing arguments and their type in R.  
**control.R** - Demonstrating use of control flows, using if, else and while statements, and for loops.  
**break.R** - Exemplifying use of 'break' in while, if and else statements.  
**next.R** - Exemplifying use of 'next' in a for loop, with an if statement.  
**Vectorize1.R** - Exemplifies time taken to use a for loop method and vectorization method for the same process.  
**Preallocate.R** - Comparing the effect if preallocation of variables on run time.  
**apply1.R** - Exemplifies use of 'apply' function in R and application to rows and columns.  
**apply2.R** - Exemplifying use of 'apply' to run functions.  
**try.R** - Compares vectorization and for loops to run simulation using 'try', with specified error message.  
**browse.R** - Exemplifying browser() function to debug R code.  
  
Biological Computing in R Practicals:  
**TreeHeight.R** - Calculates tree height from the angle to top and distance from base, and saves calculated values in csv with original data.  
**get_TreeHeight.R** - Calculates tree height from the angle to top and distance from base, and saves calculated values in csv with original data, takes data file from command line, and outputs to results.  
**run_get_TreeHeight.sh** - Runs get_TreeHeight.sh, using trees.csv as the input file.  
**Vectorize2.R** - Runs a stochastic version of the Ricker model, comparing methods using for loops and vectorization.  
**TAutoCorr.R** - iterates a function for correlation between temperatures over successive years.  
**TAutoCorr.tex** - Answer to practical question from corresponding script.  
**TAutoCorr.pdf** - Compiled version of .tex file above.  
**maps.R** - Plots a world map with data points from the specified data set.  
  
Data Management, Exploration and Visualisation:  
**DataWrang.R** - Exemplifies methods to explore data, and transfers from wide to long format.  
**Girko.R** - Plots a simulation of Girko's law and saves to pdf in Results directory.  
**plotLin.R** - Exemplifies using ggplot to annotate and manipulate plots.  
  
Data Management, Exploration and Visualisation Practicals:  
**DataWrangTidy.R** - Exemplifies data exploration and switching from wide to long format using the packages 'tidyr' and 'dplyr'.  
**PP_Lattice.R** - Produces lattice plots for the predator prey data provided and outputs as pdfs, and calculates and saves summary statistics to a csv file.  
**PP_Regress.R** - Calculating multiple regressions, saving results into a csv, and plotting regressions.  **********************************************************************

Found following files in results directory: readme.md...
Found 27 code files: browse.R, PP_Regress.R, maps.R, apply1.R, sample.R, run_get_TreeHeight.sh, Preallocate.R, boilerplate.R, TreeHeight.R, PP_Lattice.R, next.R, Ricker.R, Girko.R, Vectorize1.R, break.R, plotLin.R, basic_io.R, try.R, apply2.R, get_TreeHeight.R, TAutoCorr.R, Vectorize2.R, DataWrangTidy.R, DataWrang.R, TAutoCorr.tex, MyBars.R, control.R

Found the following extra files: TAutoCorr.pdf
0.5 pt deducted per extra file

Current Points = 99.5

======================================================================
Testing script/code files...

======================================================================
Inspecting script file browse.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: browse.R
# Desc: Exemplifying browser() function to debug R code.
# Arguments: N <- vector
# Date: 18 Oct 2018

rm(list=ls())

Exponential <- function(N0 = 1, r=1, generations = 10) {
    #run a simulation of exponential growth
    #returns a vector of lengths of generations

    N <- rep(NA, generations)

    #set starting population
    N[1] <- N0
    # start from second to end generations
    for (t in 2:generations) {
        #equation for exponential growth
       N[t] <- N[t-1] * exp(r)
       #enable debugging through browser
       browser()
    }
    return (N)
}
#plot of exponential population growth
plot(Exponential(), type = "l", main = "Exponential growth")**********************************************************************

Testing browse.R...

Output (only first 500 characters): 

**********************************************************************
Called from: Exponential()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()

**********************************************************************

Code ran without errors

Time consumed = 0.11638s

======================================================================
Inspecting script file PP_Regress.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: PP_Regress.R
# Desc: Calculating multiple regressions, saving results into a csv, and plotting
#       regressions.
# Arguments: none
# Date: 23 Oct 2018

rm(list=ls())

# packages required
require(ggplot2)
require(plyr)
require(dplyr)

# read data 
PredPrey <- read.csv("../Data/EcolArchives-E089-51-D1.csv", header=T)
# summary of data
dplyr::glimpse(PredPrey)
dplyr::tbl_df(PredPrey)

# plot figure
InterPlot <- qplot(
    # mass of preadtor against mass of prey
    Prey.mass, Predator.mass,
    # split by feeding interaction type
    facets = Type.of.feeding.interaction ~.,
    data = PredPrey,
    # using a log scale
    log = "xy",
    # set colours by predator lifestage
    colour = Predator.lifestage,
    # label axes
    xlab = "Prey Mass in grams",
    ylab = "Predator Mass in grams")
# add results of linear model to plot and position legend
Finalplot <- InterPlot + geom_smooth(method = "lm", fullrange = T) + geom_point(shape = 9) +
     theme_bw() + theme(legend.position="bottom")

# save plot to pdf
pdf("../Results/PP_Regress.pdf", 11.7, 8.3)
print(Finalplot)
graphics.off()

# regression model of interactions
model.grouped <- dlply(PredPrey, .(Type.of.feeding.interaction,Predator.lifestage), function(PredPrey) lm(log(Predator.mass)~log(Prey.mass), data=PredPrey))

# summary of the model - function generating specific values required
model.sum <- ldply(model.grouped, function(PredPrey){
    intercept <- summary(PredPrey)$coefficients[1]
    slope <- summary(PredPrey)$coefficients[2]
    p.value <- summary(PredPrey)$coefficients[8]
    R2 <- summary(PredPrey)$r.squared
    # sets values extracted as a dataframe
    data.frame(slope,intercept,R2,p.value)
})

# calculates the F statistic and data.frame
F.statistic <- ldply(model.grouped, function(PredPrey) summary(PredPrey)$fstatistic[1])
# merges the data.frame with F statistic
model.sum <- merge(model.sum, F.statistic, by = c("Type.of.feeding.interaction","Predator.lifestage"),all=T)

# set column names in data frame
names(model.sum)[3] <- "Regression.slope"
names(model.sum)[4] <- "Regression.intercept"
names(model.sum)[7] <- "F-Statistic"
names(model.sum)[6] <- "P-Value"

# write results to a csv, without quotations for strings
write.csv(model.sum,"../Results/PP_Regress_Results.csv", row.names=F, quote=F)**********************************************************************

Testing PP_Regress.R...

Output (only first 500 characters): 

**********************************************************************
Observations: 34,931
Variables: 15
$ Record.number               <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, ...
$ In.refID                    <fct> ATSH063, ATSH080, ATSH089, ATSH143, ATS...
$ IndividualID                <fct> 1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 10, 11, 1...
$ Predator                    <fct> Rhizoprionodon terraenovae, Rhizopriono...
$ Predator.common.name        <fct> Atlantic sharpnose shark, Atlantic shar...
$ Predator.taxon              <fct> ectotherm vertebrate, ectotherm ver
**********************************************************************

Encountered error:
Loading required package: ggplot2
Loading required package: plyr
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:plyr’:

    arrange, count, desc, failwith, id, mutate, rename, summarise,
    summarize

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Warning message:
In qt((1 - level)/2, df) : NaNs produced

======================================================================
Inspecting script file maps.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: maps.R
# Desc: Plots a world map with data points from the specified data set.
# Arguments: none
# Date: Oct 2018

rm(list=ls())

# require library
library(maps)

# load RData file
load("../Data/GPDDFiltered.RData")

# produce map of world
map("world")
# add data points in specified format by coordinates
points(gpdd$long,gpdd$lat,pch=19, col="blue")

## Answer to practical question:

# The distribution of the data is localised to several specific areas indicating
# biased location of data collection, and is unlikely to be suitable to be 
# examined on a global scale.**********************************************************************

Testing maps.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.17749s

======================================================================
Inspecting script file apply1.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton <k.bickerton18@imperial.ac.uk>
# Script: apply1.R
# Desc: Exemplifies use of apply function in R and application 
#       to rows and columns.
# Arguments: M <- matrix
# Date: 19 Oct 2018

rm(list=ls())

# Using the apply function to manipulate an array

# generate random matrix of 10x10
M <- matrix(rnorm(100),10,10) 

# Taking mean of each row of M
#M gives the matrix, 1 specifies by row
RowMeans <- apply(M, 1, mean) 
print(RowMeans)

# Calculating variance of each row
RowVars <- apply(M, 1, var)
print(RowVars)

# Taking mean of each column
ColMeans <- apply(M, 2, mean) # 2 specifies by column
print (ColMeans)**********************************************************************

Testing apply1.R...

Output (only first 500 characters): 

**********************************************************************
 [1] -0.02025223 -0.20494061  0.01732299 -0.04954872 -0.36520948  0.24229386
 [7] -0.10886804  0.08618386 -0.74138378 -0.09247829
 [1] 1.6124048 2.1153143 0.8827975 1.6189788 0.5743128 0.8370205 0.6427193
 [8] 0.6593220 1.0601460 1.2737835
 [1] -0.17656322 -0.30639447  0.04911064 -0.11379970 -0.13716424 -0.37790232
 [7] -0.19029232 -0.04400185 -0.03212443  0.09225146

**********************************************************************

Code ran without errors

Time consumed = 0.06514s

======================================================================
Inspecting script file sample.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: sample.R 
# Desc: Exemplifies generating a vector of 100 random values using a function and
#       the command 'sample()', then how to run function using vectorization or a 
#       for loop. 
# Arguments: none
# Date: 15 Oct 2018

rm(list=ls())

## run a simulation that involves sampling from a population

# generate ramdom population
x <- rnorm(50)
# create a function of x called "doit"
doit <- function(x) {
    # take a sample of x of the same size of x and replace current values
    x <- sample(x, replace = TRUE)
    # if the number of unique numbers in x is more than 30
    # checks sample size is sufficient
    if(length(unique(x)) > 30) { 
        # prints the mean 
        print(paste("Mean of this sample was:", as.character(mean(x))))
        }
} 

# test the function by running 100 iterations - using vectorization
result <- lapply(1:100, function(i) doit(x))

# can also calculate results using a for loop:
# preallocate format of result to a vector length 100
result <- vector("list", 100)
# for every value from 1-100, fill the vector with results calculated by the
# function doit
for(i in 1:100){
    result[[i]] <- doit(x)
}
**********************************************************************

Testing sample.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Mean of this sample was: -0.0812947999136779"
[1] "Mean of this sample was: -0.0622666997162563"
[1] "Mean of this sample was: -0.272391430947963"
[1] "Mean of this sample was: -0.0596779257827599"
[1] "Mean of this sample was: 0.241381646471449"
[1] "Mean of this sample was: -0.0954317708179908"
[1] "Mean of this sample was: -0.00414639127861599"
[1] "Mean of this sample was: 0.0168269003602825"
[1] "Mean of this sample was: -0.247608826904595"
[1] "Mean of this sample was: 0.07723156766237
**********************************************************************

Code ran without errors

Time consumed = 0.10501s

======================================================================
Inspecting script file run_get_TreeHeight.sh...

File contents are:
**********************************************************************
#!/bin/bash
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: run_get_TreeHeight.sh
# Desc: Runs get_TreeHeight.sh, using trees.csv as the input file.
# Arguments: Input -> csv file
# Date: 23 Oct 2018

# sets input file
Input="../Data/trees.csv"
# runs the Rscript using input specified above
Rscript get_TreeHeight.R $Input
# prints message below when complete
echo 'Heights calculated and saved.'
# exits process
exit**********************************************************************

Testing run_get_TreeHeight.sh...

Output (only first 500 characters): 

**********************************************************************
Heights calculated and saved.

**********************************************************************

Code ran without errors

Time consumed = 0.11232s

======================================================================
Inspecting script file Preallocate.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: Preallocate.R
# Desc: Comparing the effect if preallocation of variables on run time.
# Arguments: a -> numeric
# Date: 20 Oct 2018

rm(list=ls())

# two methods for allocating values to a vector
# both create a vector of NAs, length 100000 - which populates as function runs

# initial value of a set as NA - generates one value at a time
a <- NA
NotPreallocated <- function(a){
    for (i in 1:100000){
        # adds each individual element to a vector
        a <- c(a,i)
    }
}

# starts with dimensions of a given and structure already created, then replaces each NA
# quicker option
a <- rep(NA,10000) 
Preallocated <- function(a){
    for (i in 1:100000){
        # fills predefined vector
        a[i] <- i
    }
}

# check times taken by both options
print(system.time(NotPreallocated(a)))
print(system.time(Preallocated(a)))**********************************************************************

Testing Preallocate.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 10.00405s

======================================================================
Inspecting script file boilerplate.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: boilerplate.R
# Desc: A boilerplate script exemplifying printing arguments and their type in R.
# Arguments: Arg1, Arg2 -> no restrictions on type.
# Date: 15 Oct 2018

rm(list=ls())

# A boilerplate R script

# Make a function called 'MyFunction' which required 2 arguments
MyFunction <- function(Arg1,Arg2) {
    # prints each arguments and specifies type of argument
    print(paste("Argument", as.character(Arg1), "is a", class(Arg1))) #print Arg1's type
    print(paste("Argument", as.character(Arg2), "is a", class(Arg2))) #print Arg2's type
    # returns a vector of the input arguments
    return (c(Arg1,Arg2))
}

#testing function, first should return type as numeric, second as characters
MyFunction(3,18)
MyFunction("Riki","Tiki")**********************************************************************

Testing boilerplate.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Argument 3 is a numeric"
[1] "Argument 18 is a numeric"
[1]  3 18
[1] "Argument Riki is a character"
[1] "Argument Tiki is a character"
[1] "Riki" "Tiki"

**********************************************************************

Code ran without errors

Time consumed = 0.09016s

======================================================================
Inspecting script file TreeHeight.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: TreeHeight.R
# Desc: Calculates tree height from the angle to top and distance from base, and
#       saves calculated values in csv with original data.
# Arguments: degrees -> angle in radians from top, distance -> distance to base of tree
# Date: 15 Oct 2018

rm(list=ls())

# Script to calculate tree height from distance to base and angle to top

# Equation for calculation:
# height = distance * tan(radians)

# Output
# The heights of the tree, same units as distance

# load csv file containing arguments needed
Trees <- read.csv("../Data/trees.csv", header=TRUE)

# for every row in data
for (i in Trees) {
    # calculate angle from top in radians
    radians <- Trees$Angle.degrees * pi /180
    # calculate height of tree using distance and angle calculated above
    height <- Trees$Distance.m * tan(radians)
    # save height in a vector
    Height.m <- c(height)
}
# create a data frame from data Trees and calculated heights
TreeHeight <- data.frame(Trees, Height.m)
# write dataframe to csv file and output in Results directory
write.csv(TreeHeight,"../Results/TreeHts.csv")

**********************************************************************

Testing TreeHeight.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.09246s

======================================================================
Inspecting script file PP_Lattice.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: PP_Lattice.R
# Desc: Produces lattice plots for the predator prey data provided and outputs as
#       pdfs, and calculates and saves summary statistics to a csv file.
# Arguments: none 
# Date: 22 Oct 2018

rm(list=ls())

# required packages for analysis
require(lattice)
require(dplyr)
require(ggplot2)

# load the csv data file and assign to variable
PredPrey <- read.csv("../Data/EcolArchives-E089-51-D1.csv", header=T)
# view a portion of the data
dplyr::tbl_df(PredPrey)
dplyr::glimpse(PredPrey)

## for the three sections below:

# opens blank pdf in specified location, of specified size
pdf("../Results/Prey_Lattice.pdf", 11.7,8.3)
# plots lattice plot of variable, stratified by feeding interaction type
qplot(log(Prey.mass), facets = Type.of.feeding.interaction ~., 
    data = PredPrey, geom = "density", xlab="Prey Mass (kg)")
    # finished recording to pdf
dev.off()

pdf("../Results/Pred_Lattice.pdf", 11.7,8.3)
qplot(log(Predator.mass), facets = Type.of.feeding.interaction ~., 
    data = PredPrey, geom = "density", xlab="Predator Mass (kg)")
dev.off()

pdf("../Results/SizeRatio_Lattice.pdf",11.7,8.3)
qplot(log(Predator.mass/Prey.mass), facets = Type.of.feeding.interaction ~., 
    data = PredPrey, geom = "density", xlab="Ratio of Predator to Prey Mass")
dev.off()


## for three sections below:

# provides summary data of variable by feeding interaction
Prey <- PredPrey %>% group_by(Type.of.feeding.interaction) %>% summarise(
    Mean= mean(log(Prey.mass)), Median = median(log(Prey.mass))
)
# sets new column in data
Prey$"Type" <- "Log.Prey.Mass"

Pred <- PredPrey %>% group_by(Type.of.feeding.interaction) %>% summarise(
    Mean= mean(log(Predator.mass)), Median = median(log(Predator.mass))
)
Pred$"Type" <- "Log.Predator.Mass)"

PredPreyRatio <- PredPrey %>% group_by(Type.of.feeding.interaction) %>% summarise(
    Mean= mean(log(Predator.mass/Prey.mass)), Median = median(log(Predator.mass/Prey.mass))
)
PredPreyRatio$"Type" <- "Log.predator.prey.size.ratio"

# binds summary rows
SummaryStats <- rbind(Pred,Prey,PredPreyRatio)
# writes summary statistics to csv in Results directory
write.csv(SummaryStats, "../Results/PP_Results.csv", row.names=F )**********************************************************************

Testing PP_Lattice.R...

Output (only first 500 characters): 

**********************************************************************
# A tibble: 34,931 x 15
   Record.number In.refID IndividualID Predator Predator.common… Predator.taxon
           <int> <fct>    <fct>        <fct>    <fct>            <fct>         
 1             1 ATSH063  1            Rhizopr… Atlantic sharpn… ectotherm ver…
 2             2 ATSH080  2            Rhizopr… Atlantic sharpn… ectotherm ver…
 3             3 ATSH089  3            Rhizopr… Atlantic sharpn… ectotherm ver…
 4             4 ATSH143  4            Rhizopr… Atlantic sharpn… ectotherm ve
**********************************************************************

Encountered error:
Loading required package: lattice
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Loading required package: ggplot2

======================================================================
Inspecting script file next.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: next.R 
# Desc: Exemplifying use of 'next' in a for loop, with an if statement.
# Arguments: i <- numeric
# Date: 15 Oct 2018

rm(list=ls())

# for i in the range 1-10
for (i in 1:10) {
    # if i is a multiple of 2
    if((i %% 2) == 0)
    # start next run of the loop
        next 
    # if not true, print the value of i
    print(i)
}
# with these parameters, outputs a list of odd numbers between 1 and 10**********************************************************************

Testing next.R...

Output (only first 500 characters): 

**********************************************************************
[1] 1
[1] 3
[1] 5
[1] 7
[1] 9

**********************************************************************

Code ran without errors

Time consumed = 0.09433s

======================================================================
Inspecting script file Ricker.R...

File contents are:
**********************************************************************
Ricker <- function(N0=1, r=1, K=10, generations=50)
{
  # Runs a simulation of the Ricker model
  # Returns a vector of length generations

  N <- rep(NA, generations)    # Creates a vector of NA

  # defining equation for Ricker model
  N[1] <- N0
  for (t in 2:generations)
  {
    N[t] <- N[t-1] * exp(r*(1.0-(N[t-1]/K)))
  }
  return (N)
}

plot(Ricker(generations=10), type="l")**********************************************************************

Testing Ricker.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.12905s

======================================================================
Inspecting script file Girko.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: Girko.R
# Desc: Plots a simulation of Girko's law and saves to pdf in Results directory.
# Arguments: none
# Date: 22 Oct 2018

rm(list=ls())

# function that returns an ellipse
build_ellipse <- function(hradius, vradius){ 
  npoints = 250
  a <- seq(0, 2 * pi, length = npoints + 1)
  x <- hradius * cos(a)
  y <- vradius * sin(a)  
  return(data.frame(x = x, y = y))
}

N <- 250 # Assign size of the matrix
M <- matrix(rnorm(N * N), N, N) # Build the matrix
eigvals <- eigen(M)$values # Find the eigenvalues
eigDF <- data.frame("Real" = Re(eigvals), "Imaginary" = Im(eigvals)) # Build a dataframe
my_radius <- sqrt(N) # The radius of the circle is sqrt(N)
ellDF <- build_ellipse(my_radius, my_radius) # Dataframe to plot the ellipse
names(ellDF) <- c("Real", "Imaginary") # rename the columns


# plot the eigenvalues
require(ggplot2)
# uses ggplot to plot eigenvalues on real and imaginary axes
p <- ggplot(eigDF, aes(x = Real, y = Imaginary))
p <- p +
  # specifies shape of points
  geom_point(shape = I(3)) +
  # removes legend
  theme(legend.position = "none")

# now add the vertical and horizontal line
p <- p + geom_hline(aes(yintercept = 0))
p <- p + geom_vline(aes(xintercept = 0))

# finally, add the ellipse
p <- p + geom_polygon(data = ellDF, aes(x = Real, y = Imaginary, alpha = 1/20, fill = "red"))
# prints image to pdf
pdf("../Results/Girko.pdf")
print(p)
dev.off()
**********************************************************************

Testing Girko.R...

Output (only first 500 characters): 

**********************************************************************
null device 
          1 

**********************************************************************

Encountered error:
Loading required package: ggplot2

======================================================================
Inspecting script file Vectorize1.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: Vectorize1.R 
# Desc: Exemplifies time taken to use a for loop method and vectorization method 
#       for the same process.
# Arguments: M -> a randomly generated matrix
# Date: 20 Oct 2018

rm(list=ls())

#generate a 1000x1000 matrix of random numbers up to 1million
M <- matrix(runif(100000),1000,1000)

# define a function of the matrix
SumAllElements <- function(M) {
    # set a variable to the same dimensions as the matrix
    Dimensions <- dim(M) 
    # initial value of Tot
    Tot <- 0 
    # for every row in the matrix
    for (i in 1:Dimensions[1]){ 
        # for every column in the matrix
        for (j in 1:Dimensions[2]){ 
            #add each element
            Tot <- Tot + M[i,j] 
        }
    }
    # return the total sum
    return (Tot) 
 }

 # comparison of the time taken using SumAllElements() and sum()
 # longer method as runs a for loop
 print(system.time(SumAllElements(M)))
 # quicker as draws on an inbuilt function (originall a program written C) which 
 # is more primitive and faster to run
 print(system.time(sum(M)))**********************************************************************

Testing Vectorize1.R...

Output (only first 500 characters): 

**********************************************************************
   user  system elapsed 
  0.076   0.004   0.083 
   user  system elapsed 
  0.000   0.000   0.001 

**********************************************************************

Code ran without errors

Time consumed = 0.18405s

======================================================================
Inspecting script file break.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: break.R
# Desc: Exemplifying use of 'break' in while, if and else statements.
# Arguments: i <- numeric 
# Date: 15 Oct 2018

rm(list=ls())

# set initial value of i
i <- 0 
# while i is less than infinity
    while(i<Inf) {
        # when i is 20
        if (i==20) {
            # break while loop
            break } 
        # if i is not 20
        else { 
            # print the value of i and start a new line
            cat("i equals " , i, "\n")
            # increase value of i by 1 each loop
            i <- i+1 
        }
    }**********************************************************************

Testing break.R...

Output (only first 500 characters): 

**********************************************************************
i equals  0 
i equals  1 
i equals  2 
i equals  3 
i equals  4 
i equals  5 
i equals  6 
i equals  7 
i equals  8 
i equals  9 
i equals  10 
i equals  11 
i equals  12 
i equals  13 
i equals  14 
i equals  15 
i equals  16 
i equals  17 
i equals  18 
i equals  19 

**********************************************************************

Code ran without errors

Time consumed = 0.08804s

======================================================================
Inspecting script file plotLin.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: plotLin.R
# Desc: Exemplifies using ggplot to annotate and manipulate plots.
# Arguments: none
# Date: 22 Oct 2018

rm(list=ls())#Mathematical display

require(ggplot2)

x <- seq(0, 100, by = 0.1)
y <- -4. + 0.25 * x +
  rnorm(length(x), mean = 0., sd = 2.5)

# and put them in a dataframe
my_data <- data.frame(x = x, y = y)

# perform a linear regression
my_lm <- summary(lm(y ~ x, data = my_data))

# plot the data
p <-  ggplot(my_data, aes(x = x, y = y,
                          colour = abs(my_lm$residual))
             ) +
  # add points to the data
  geom_point() +
  # sets colours of gradient
  scale_colour_gradient(low = "black", high = "red") +
  # removes legend
  theme(legend.position = "none") +
  # sets scale to contiuous labelled with expression
  scale_x_continuous(
    expression(alpha^2 * pi / beta * sqrt(Theta)))

# add the regression line
p <- p + geom_abline(
  # specify intercept
  intercept = my_lm$coefficients[1][1],
  # specify gradient
  slope = my_lm$coefficients[2][1],
  # specify colour
  colour = "red")
# annotate plot using equation
p <- p + geom_text(aes(x = 60, y = 0,
                       label = "sqrt(alpha) * 2* pi"), 
                       parse = TRUE, size = 6, 
                       colour = "blue")

# save plot as a pdf
pdf("../Results/MyLinReg.pdf")
print(p)
dev.off()**********************************************************************

Testing plotLin.R...

Output (only first 500 characters): 

**********************************************************************
null device 
          1 

**********************************************************************

Encountered error:
Loading required package: ggplot2

======================================================================
Inspecting script file basic_io.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: basic_io.R
# Desc: Demonstrating input and output of csv files, including appending.
# Arguments: none
# Date: 15 Oct 2018

rm(list=ls())

# Import csv file with headers
MyData = read.csv("../Data/trees.csv", header = TRUE)
# Write input as a new file called MyData, and output to Results directory
write.csv(MyData, "../Results/MyData.csv") 
# Append csv file, also need to ignore column names when appending
# by default col.names is TRUE, leading to appending headings as well as data
write.table(MyData[1,], file = "../Results/MyData.csv",append=TRUE,col.names=FALSE)
# write csv with row names
write.csv(MyData, "../Results/MyData.csv", row.names=TRUE)**********************************************************************

Testing basic_io.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.07859s

======================================================================
Inspecting script file try.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: try.R
# Desc: Compares vectorization and for loops to run simulation using 'try', with
#       specified error message.
# Arguments: x <- vector
# Date: 21 Oct 2018

rm(list=ls())## run a simulation that involves sampling from a population

x <- rnorm(50) #generate your population
doit <- function(x) {
    x <- sample(x, replace = TRUE)
    if(length(unique(x)) > 30) { #only take mean if sample was sufficient
        print(paste("Mean of this sample was:", as.character(mean(x))))
        }
    else { 
        # stop generates the specified error message
        stop("Couldn't calculate mean: too few unique points!")
    }
} 

## Run 100 iterations using vectorization with try:
result <- lapply(1:100, function(i) try(doit(x), FALSE))

## Or using a for loop:
result <- vector("list", 100) #preallocate/initialise
for(i in 1:100){
    # false in function prevents error messages from being surpressed
    result[[i]] <- try(doit(x),FALSE)
}**********************************************************************

Testing try.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Mean of this sample was: -0.174547649089957"
[1] "Mean of this sample was: -0.0890198889707719"
[1] "Mean of this sample was: -0.183232394763144"
[1] "Mean of this sample was: -0.133288595085587"
[1] "Mean of this sample was: 0.0942820409623734"
[1] "Mean of this sample was: -0.0308791283408734"
[1] "Mean of this sample was: -0.146150437381834"
[1] "Mean of this sample was: 0.030626546765"
[1] "Mean of this sample was: -0.0458150106733152"
[1] "Mean of this sample was: -0.0338929053523923"
[
**********************************************************************

Encountered error:
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!

======================================================================
Inspecting script file apply2.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: apply2.R
# Desc: Exemplifying use of apply to run functions.
# Arguments: v <- numeric
# Date: 19 Oct 2018

rm(list=ls())

# for the matrix v, if the sum is greater than 0, return value *100, if not, keep value
SomeOperation <- function(v){
    if (sum(v) > 0){
        return(v * 100)
    }
    return(v)
}

# generates a random matrix of 100 values from a normal distribution
M <- matrix(rnorm(100,10,10))
# print output of function and uses apply to run function
print (apply(M, 1, SomeOperation))**********************************************************************

Testing apply2.R...

Output (only first 500 characters): 

**********************************************************************
  [1]   -4.1245625   -1.9383969   99.5075353 1490.4588972  223.6604033
  [6] 2900.7705672 1380.1062706 2501.5959875  682.5236815  683.5471970
 [11] 1258.5742981 2865.7674378   -1.1856873 1636.7953323 2578.8635647
 [16]   97.3153400   -1.2284353 1846.8167228 1704.9455929   -3.6922072
 [21] 2097.4974570 1291.6883337   -3.9489074   -4.5411534 1322.2609510
 [26] 1396.0409675  481.8528543 1505.3499552 2523.2036820   -9.6972906
 [31] 2554.8474145 1936.5547384  573.3487565 2399.4642879   78.1989263
 [36
**********************************************************************

Code ran without errors

Time consumed = 0.08935s

======================================================================
Inspecting script file get_TreeHeight.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: get_TreeHeight.R
# Desc: Calculates tree height from the angle to top and distance from base, and
#       saves calculated values in csv with original data, takes data file from 
#       command line, and outputs to results.
# Arguments: Input <- csv file, from command line.
# Date: 16 Oct 2018

rm(list=ls())

# set input file to be taken from the command line
Input = commandArgs(trailingOnly = TRUE)

# read input and set to Trees
Trees <- read.csv(Input, header=TRUE)


# for every row in data
for (i in Trees) {
    # calculate angle from top in radians
    radians <- Trees$Angle.degrees * pi /180
    # calculate height of tree using distance and angle calculated above
    height <- Trees$Distance.m * tan(radians)
    # save height in a vector
    Height.m <- c(height)
}

# create data frame of original data and new calculated heights
TreeHeight <- data.frame(Trees, Height.m)
# create output name by taking input name and removing file extension:
# first spliting name at /
Output <- unlist(strsplit(Input, split="/", fixed=TRUE))[-1][-1]
# then substituting .csv for nothing
Output<- gsub(".csv", "", Output)

# save dataframe as output name with _treeheights.csv on end into Results directory
write.csv(TreeHeight,file = paste0("../Results/",Output,"_treeheights.csv"))
**********************************************************************

Testing get_TreeHeight.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Error in file(file, "rt") : invalid 'description' argument
Calls: read.csv -> read.table -> file
Execution halted

======================================================================
Inspecting script file TAutoCorr.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: TAutoCorr.R
# Desc: # iterates a function for correlation between temperatures over successive
        # years
# Arguments: none
# Date: 22 Oct 2018

rm(list=ls())

load("../Data/KeyWestAnnualMeanTemperature.RData")
# str(ats)
# plot(ats)

# two subsets of the data
temps1<-ats[1:98,2]
temps2<-ats[2:99,2]

# calculate correlation of original data
a = cor(temps1, temps2)

# randomly selects values in the dataset and calculates correlation
temp <- function(x,y) {
    s1<-sample(x,length(x))
    s2<-sample(y,length(y))
    cor(s1,s2)
}

# run the function temp, 10000 times 
results <- lapply(1:10000,function(i) temp(temps1,temps2))

# calculate and print the p value, based on the 10000 iterations
print("The approximate p-value is" )
print(length(results[results>a])/length(results))**********************************************************************

Testing TAutoCorr.R...

Output (only first 500 characters): 

**********************************************************************
[1] "The approximate p-value is"
[1] 7e-04

**********************************************************************

Code ran without errors

Time consumed = 0.54944s

======================================================================
Inspecting script file Vectorize2.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: Vectorize.R
# Desc: Runs a stochastic version of the Ricker model, comparing methods using
#       for loops and vectorization.
# Arguments: p0 <- intial population
# Date: 20 Oct 2018

# Runs the stochastic (with gaussian fluctuations) Ricker Eqn .
#remove R history
rm(list=ls())

# Before vectorization
stochrick<-function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
  #initialize
  N<-matrix(NA,numyears,length(p0))
  N[1,]<-p0
  
  #for every population
  for (pop in 1:length(p0)) {
  #for every year in each population
   for (yr in 2:numyears) 
    {
      #stochastic Ricker equation:
    N[yr,pop]<-N[yr-1,pop]*exp(r*(1-N[yr-1,pop]/K)+rnorm(1,0,sigma))
    }
  }
 return(N)
}

# Now write another function called stochrickvect that vectorizes the above 
# to the extent possible, with improved performance: 

# Vectorized version
stochrickvect<-function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
  #initialize
  N<-matrix(NA,numyears,length(p0))
  N[1,]<-p0
  
  #for (pop in 1:length(p0)) #loop through the populations
  
  for (yr in 2:numyears) #for each pop, loop through the years
    {
    N[yr,]<-N[yr-1,]*exp(r*(1-N[yr-1,]/K)+rnorm(1,0,sigma))
    }

 return(N)
}

# print the time taken for the original function
print("Stochastic Ricker takes:")
print(system.time(stochrick()))
# and the time taken for the vectorized function
print("Vectorized Stochastic Ricker takes:")
print(system.time(stochrickvect()))**********************************************************************

Testing Vectorize2.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Stochastic Ricker takes:"
   user  system elapsed 
  0.248   0.000   0.248 
[1] "Vectorized Stochastic Ricker takes:"
   user  system elapsed 
  0.012   0.000   0.011 

**********************************************************************

Code ran without errors

Time consumed = 0.34443s

======================================================================
Inspecting script file DataWrangTidy.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: DataWrangTidy.R
# Desc: Exemplifies data exploration and switching from wide to long format using
#       the packages 'tidyr' and 'dplyr'.
# Arguments: none
# Date: 22 Oct 2018

rm(list=ls())


################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################

############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../Data/PoundHillData.csv",header = F)) 

# header = true because we do have metadata headers
MyMetaData <- read.csv("../Data/PoundHillMetaData.csv",header = T, sep=";", stringsAsFactors = F)

require(dplyr)
require(tidyr)
############# Inspect the dataset ###############
# displays structure of data including dimensions
# same as the str() function
dplyr::glimpse(MyData)
# same as head but includes more info including dimensions
dplyr::tbl_df(MyData) 
dplyr::tbl_df(MyMetaData)
# view data in table
utils::View(MyData)


############# Transpose ###############
# To get those species into columns and treatments into rows 
MyData <- t(MyData) 
dplyr::tbl_df(MyData)

############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0

############# Convert raw matrix to data frame ###############

# set a data frame, excluding first row of MyData
# creates data frame TempData and removes first row from MyData
TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) 
#stringsAsFactors = F prevents conversion to factors
colnames(TempData) <- MyData[1,] # assign column names from original data

############# Convert from wide to long format  ###############

# reduces data instead of separate counts - long format
MyWrangledData <- TempData %>% gather(., Species, Count, -Cultivation, 
    -Block, -Plot, -Quadrat)
# assign correct data types and set as factors
MyWrangledData <- MyWrangledData %>% mutate(Cultivation = as.factor(Cultivation),
    Block = as.factor(Block), Plot = as.factor(Block), 
    Quadrat = as.factor(Quadrat), Count = as.integer(Count))

dplyr::glimpse(MyWrangledData)
dplyr::tbl_df(MyWrangledData)

############# Start exploring the data (extend the script below)!  ###############
**********************************************************************

Testing DataWrangTidy.R...

Output (only first 500 characters): 

**********************************************************************
 chr [1:45, 1:60] "Cultivation" "Block" "Plot" "Quadrat" ...
 - attr(*, "dimnames")=List of 2
  ..$ : NULL
  ..$ : chr [1:60] "V1" "V2" "V3" "V4" ...
# A tibble: 45 x 60
   V1       V2     V3     V4    V5    V6    V7    V8    V9    V10   V11   V12  
   <chr>    <chr>  <chr>  <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr>
 1 Cultiva… octob… octob… octo… octo… octo… may   may   may   may   may   march
 2 Block    a      a      a     a     a     a     a     a     a     a     a    
 3 Plot    
**********************************************************************

Encountered error:
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Loading required package: tidyr

======================================================================
Inspecting script file DataWrang.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: DataWrang.R
# Desc: Exemplifies methods to explore data, and transfers from wide to long
#       format.
# Arguments: none
# Date: 22 Oct 2018

rm(list=ls())


################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################

############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../Data/PoundHillData.csv",header = F)) 

# header = true because we do have metadata headers
MyMetaData <- read.csv("../Data/PoundHillMetaData.csv",header = T, sep=";", stringsAsFactors = F)

############# Inspect the dataset ###############
# prints first few rows of data
head(MyData)
# gives dimensions of matrix
dim(MyData)
# displays structure of object
str(MyData)
# view data in table
fix(MyData) #you can also do this
fix(MyMetaData)

############# Transpose ###############
# To get those species into columns and treatments into rows 
MyData <- t(MyData) 
head(MyData)
dim(MyData)

############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0

############# Convert raw matrix to data frame ###############

# set a data frame, excluding first row of MyData
# creates data frame TempData and removes first row from MyData
TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) 
#stringsAsFactors = F prevents conversion to factors
colnames(TempData) <- MyData[1,] # assign column names from original data

############# Convert from wide to long format  ###############
require(reshape2) # load the reshape2 package

#?melt #check out the melt function

# reduces data instead of separate counts - long format
MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), 
variable.name = "Species", value.name = "Count")

# assign correct data types and set as factors
MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.numeric(MyWrangledData[, "Count"])

# view summary of data again
str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)

############# Start exploring the data (extend the script below)!  ###############
**********************************************************************

Testing DataWrang.R...

Output (only first 500 characters): 

**********************************************************************
     V1                     V2        V3        V4        V5        V6       
[1,] "Cultivation"          "october" "october" "october" "october" "october"
[2,] "Block"                "a"       "a"       "a"       "a"       "a"      
[3,] "Plot"                 "1"       "1"       "1"       "1"       "1"      
[4,] "Quadrat"              "Q1"      "Q2"      "Q3"      "Q4"      "Q5"     
[5,] "Achillea millefolium" "4"       "8"       "3"       "20"      "6"      
[6,] "Agrostis gigantea"    ""   
**********************************************************************

Code ran without errors

Time consumed = 10.01319s

======================================================================
Inspecting script file TAutoCorr.tex...

File contents are:
**********************************************************************
\documentclass[11pt]{article}
\title{Relationship between temperature change over successive years in Key West, Florida, during the 20th century}
\author{Katie Bickerton}
\date{23 Oct 2018}


\begin{document}
    \maketitle

   	\section{Analysis and Results}
   	\paragraph{}To analyse the correlation in temperature change over successive years of the 20th century, data was matched and the initial correlation calculated. The data was then randomly sampled and correlation calculated over 10000 iterations. The p-value was then calculated using the proportion of correlations above the original value, 0.326. This gave a value of p $<$ 0.001, indicating that there was a significant correlation in temperature change over successive years, when compared to a random sample of years. 
   	
   	\paragraph{}These results indicate that temperature has changed successively over time. The correlation between successive years was a weak positive trend, indicating that the temperature has increased during the 20th century in Key West, Florida.
   	
   	

 \end{document}**********************************************************************

Testing TAutoCorr.tex...

======================================================================
Inspecting script file MyBars.R...

File contents are:
**********************************************************************
# Annotating plots

require(ggplot2)
a <- read.table("../Data/Results.txt", header = TRUE)

a$ymin <- rep(0, dim(a)[1]) # append a column of zeros

# Print the first linerange
p <- ggplot(a)
p <- p + geom_linerange(data = a, aes(
                          x = x,
                          ymin = ymin,
                          ymax = y1,
                          size = (0.5)
                          ),
                        colour = "#E69F00",
                        alpha = 1/2, show.legend = FALSE)

# Print the second linerange
p <- p + geom_linerange(data = a, aes(
                          x = x,
                          ymin = ymin,
                          ymax = y2,
                          size = (0.5)
                          ),
                        colour = "#56B4E9",
                        alpha = 1/2, show.legend = FALSE)

# Print the third linerange:
p <- p + geom_linerange(data = a, aes(
                          x = x,
                          ymin = ymin,
                          ymax = y3,
                          size = (0.5)
                          ),
                        colour = "#D55E00",
                        alpha = 1/2, show.legend = FALSE)

# Annotate the plot with labels:
p <- p + geom_text(data = a, aes(x = x, y = -500, label = Label))

# now set the axis labels, remove the legend, and prepare for bw printing
p <- p + scale_x_continuous("My x axis",
                            breaks = seq(3, 5, by = 0.05)) + 
                            scale_y_continuous("My y axis") + 
                            theme_bw() + 
                            theme(legend.position = "none") 

pdf("../Results/MyBars.pdf")
print(p)
dev.off()**********************************************************************

Testing MyBars.R...

Output (only first 500 characters): 

**********************************************************************
null device 
          1 

**********************************************************************

Encountered error:
Loading required package: ggplot2
Warning message:
Removed 91 rows containing missing values (geom_text). 

======================================================================
Inspecting script file control.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: Katie Bickerton k.bickerton18@imperial.ac.uk
# Script: control.R 
# Desc: Demonstrating use of control flows, using if, else and while statements,
#       and for loops.
# Arguments: none
# Date: Oct 2018

rm(list=ls())

## If statement example
# initial value of a set
a <- TRUE
# if a is true
if (a == TRUE) {
   # print to terminal
   print ("a is TRUE")
   # if not true
} else {
    # print to terminal
print ("a is FALSE")
}

# set z to a value from a random distribution between 0-1
z <- runif(1)
# if z is less than or equal to 0.5
if (z <= 0.5) {
    # print the below message
    print ("Less than a quarter")
}

## For loop using a sequence
# for every value between 1-100
for (i in 1:100) {
    # set j equal to the square of the value of i
    j <- i * i
    # print the statement below
    print(paste(i, " squared is", j))
}

## For loop over vector of strings
# for every species in the vector of strings
for(species in c('Heliodoxa rubinoides',
                 'Boissonneaua jardini',
                 'Sula nebouxii'))
{
    # print the statement below:
    print(paste('The species is', species))
}

## For loop using a vector
# set v1 to a vector of strings
v1 <- c("a","bc","def")
# for every value of the vector v1
for (i in v1) {
    # print the value of v1
    print(i)
}

## While loop
# set initial value of i
i <- 0
# while i is less than 100
while(i<100) {
    # reset value of i to i+1 (next step up)
    i <- i+1
    # print the value of i squared
    print(i^2)
}**********************************************************************

Testing control.R...

Output (only first 500 characters): 

**********************************************************************
[1] "a is TRUE"
[1] "1  squared is 1"
[1] "2  squared is 4"
[1] "3  squared is 9"
[1] "4  squared is 16"
[1] "5  squared is 25"
[1] "6  squared is 36"
[1] "7  squared is 49"
[1] "8  squared is 64"
[1] "9  squared is 81"
[1] "10  squared is 100"
[1] "11  squared is 121"
[1] "12  squared is 144"
[1] "13  squared is 169"
[1] "14  squared is 196"
[1] "15  squared is 225"
[1] "16  squared is 256"
[1] "17  squared is 289"
[1] "18  squared is 324"
[1] "19  squared is 361"
[1] "20  squared is 400"
[1] "2
**********************************************************************

Code ran without errors

Time consumed = 0.09555s

======================================================================
======================================================================
Finished running scripts

Ran into 8 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 99.5

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!